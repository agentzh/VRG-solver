program : statement(s) eofile { join "\n\n", grep $_, @{ $item[1] } }
        | <error>

comment : /\/\*(.*?)\*\//s  { my $cmt = "; $1"; $cmt =~ s/\n(?=.)/;/g; $cmt }

rule : disjunction '=>' <commit> new_facts '.' ws

        { $::count++;
          "; $::infile (line $itempos[1]{line}{from} ~ $itempos[5]{line}{to})\n".
          "(defrule $::module$::base-$::count\n".
          "    $item[1]\n".
          "    =>\n".
          "$item[4])" }

     | <error?> <reject>

disjunction : conjunction ';' <commit> disjunction

    { "(or $item{conjunction} $item{disjunction})" }
    
            | conjunction
            | <error?> <reject>

conjunction : clause ',' <commit> conjunction

    { "(and $item{clause} $item{conjunction})" }

            | clause
            | <error?> <reject>

clause : prefix <skip:''> <commit> atom

            { "($item{prefix} $item{atom})" }

       | atom <skip:''> /\s+/ general_infix <skip:'\s*'> atom
       
            { "($item{general_infix} $item[1] $item[6])" }
       
       | atom <skip:''> postfix

            { "($item{postfix} $item{atom})" }

       | atom
       | <error?> <reject>

prefix : { ::match_prefix($text) } { $::prefix{$item[1]} }

atom : predicate
     | variable
     | literal

predicate : identifier '(' ')' { "($item{identifier})" }
		  | identifier '(' <commit> arguments ')'  { "($item[1] $item{arguments})" }
          | <error?> <reject>

eofile : /^\Z/

statement : comment
          | directive
          | rule
          | facts '.' ws  { '' }

facts : fact ',' <commit> facts
      | fact
      | <error?> <reject>

fact : clause   { push @::facts, "; $::infile (line $itempos[1]{line}{from} ~ ".
                    "$itempos[1]{line}{to})",
                    "$item{clause}\n"; '' }

ws: /[\n\s]*/

directive : 'module' <commit> identifier '.' ws

        { $::module = $item{identifier} . '::'; '' }

          | 'include' <commit> string '.' ws

        { my $res = ::process_include(eval $item{string}, $itempos[1]{line}{from}) }

          | 'define' <commit> predicate '.' ws

        { $item{predicate} }

          | 'prefix:<' <commit> <skip:''> pattern '>' <skip:'\s*'> string '.' ws
          
        { $::prefix{$item{pattern}} = eval $item{string}; '' }

          | 'infix:<' <commit> <skip:''> pattern '>' <skip:'\s*'> string '.' ws

        { $::infix{$item{pattern}} = eval $item{string}; '' }

          | 'infix_prefix:<' <commit> <skip:''> pattern '>' <skip:'\s*'> string '.' ws

        { $::infix_prefix{$item{pattern}} = eval $item{string}; '' }

          | 'infix_circumfix:<' <commit> <skip:''> circum_pattern '>'
		    <skip:'\s*'> string '.' ws

        {   my $pattern = $item{circum_pattern};
		    #warn "~~~ @$pattern\n";
			$::infix_circumfix{$pattern->[0]} = eval $item{string};
			$::infix_circum_close{$pattern->[0]} = $pattern->[1]; '' }

          | <error?> <reject>

pattern : /\S+(?=>)/

circum_pattern : /(\S+) (\S+)(?=>)/ { [$1, $2] }

new_facts : new_fact ',' <commit> new_facts

              { $item{new_fact} . $item{new_facts} }

          | new_fact
          | <error?> <reject>

new_fact : clause

    { $item[1] =~ /^\(bind\b/ ? "    $item[1]\n" : "    (assert $item[1])\n" }

general_infix : infix_circum_open <commit> infix
                { ::match_infix_circum_close($text, $item[1]) }

			{ $::infix_circumfix{$item[1]} . " " . $item{infix} }

			  | infix_prefix <commit> infix  { "$item{infix_prefix} $item{infix}" }
              | infix
              | <error?> <reject>

infix_circum_open : { ::match_infix_circum_open($text) }

arguments : <leftop: clause ',' clause>  { join ' ', @{ $item[1] } }

variable : /\?[A-Za-z_]([-\w])*/  { $item[1] . $item{identifier} }
         | '?'

literal : identifier
        | number
        | string

identifier : /[A-Za-z_]([-\w])*/

number : /\d+(?:\.\d*)?/
       | /\.\d+/

string : { extract_delimited($text, '"') }

infix_prefix : { ::match_infix_prefix($text) } { $::infix_prefix{$item[1]} }

infix : variable
      | { ::match_infix($text) } { $::infix{$item[1]} }

postfix : 'postfix'

compound: <leftop: clause /([;,])/ clause>

    { "\n    " . join "", (map { m/^[;,]$/ ? "$_\n    " : $_ } @{ $item[1] }); }
